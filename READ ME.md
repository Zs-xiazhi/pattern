# 创建型模式
对象实例化的模式，创建型模式用于解耦对象的实例化过程。
 ## 1. 单例模式(singleton-pattern)
    保证类只被实例化一次
   
    五种单例模式实现方式：
    1. 懒汉模式：线程不安全。
    2. 饿汉模式：类加载是创建对象，线程安全。无法做到延迟加载。
    3. DCL单例：volatile防止指令重排序。懒汉式升级版
    4. 静态内部类：饿汉模式升级版，解决饿汉模式午饭延迟加载
    5. 枚举：jvm保证单例
    
 ## 2. 工厂模式(factory-pattern)
    通过工厂来创建对象，如果有新增的产品只需要在工厂中增加一个产品就行了，
 ## 3. 抽象工厂模式(abstract-factory-pattern)
    每个工厂的产品分为多个子产品，例如：
    现在有产品A、B、C，我们使用工厂模式，来生产A、B、C三个产品，但是现在A产品又分为A1,A3,B产品又分为B1,B2,C产品又分为C1,C2;
    此时使用抽象工厂来生产A、B、C三个产品，而抽象工厂又有两个子类，工厂1生产A1,B1,C1;工厂2生产A2,B2,C2。
 ## 4. 原型模式(prototype-pattern)
    原型模式就是重写clone方法，Cloneable接口标记这是一个可以被克隆的对象。通过调用clone方法复制一个对象。
 ## 5. 建造者模式(builder-pattern)
    对于一个复杂的对象，通过建造者模式一步步去建造需要的都对象。
    
    一个对象有多个行为，多个行为就会有多种的组合方式，例如：一个人有吃饭，睡觉，运动，娱乐等行为。那么这些行为的执行方式就会有多种，可以是：
    1. 吃饭->睡觉->运动->娱乐
    2. 运动->吃饭->娱乐->睡觉 ............
    等等，组合方式多种多样，那么通过建造者模式，就可以在外部指定对象的方法执行顺序。
# 结构型模式
 ## 1. 桥接模式(bridge-pattern)
    桥梁模式是象桥梁一样将两个业务对象关联起来，通过改变传入的业务对象，影响另一端的结果。
    一个类具有两个独立变化的维度，且这两个维度都需要拓展。
 ## 2. 适配器模式(adapter-pattern)
    通过适配器模式来接入外部数据，并将外部数据的类型转换为自己系统内部的数据类型，调用时就像调用自己内部的数据一样。
 ## 3. 装饰模式(decorator-pattern)
    动态的为一个类添加功能。解决继承子类过多的问题。
 ## 4. 外观模式(facade-pattern)
    对一个对象的内部顺序做一个封装，用户通过封装对象来操作对象，主要为了解藕，隐藏代码具体实现。
 ## 5. 组合模式(composite-pattern)
    组合模式的三个构件：
    1. 抽象构件角色：定义参与组合的对象的共有方法和属性，可以定义一些默认的行为或属性。
    2. 树枝构件：树枝对象，作用是组合树枝节点和叶子节点。
    3. 叶子构件：叶子对象，下边没有其他分支
    两个模式：
    安全模式：叶子节点和树枝节点方法不一样。比较安全。
    透明模式：叶子节点和树枝节点拥有相同的行为和方法，通过getChild（）是否为空判断是叶子节点还是树枝节点。容易引发运行时异常。
 ## 6. 亨元模式(flyweight-pattern)
    运用共享技术来减少对象的创建，提高系统资源利用率
    优点：相同对
 ## 7. 代理模式(proxy-pattern)
    假设有一个接口或抽象类，代理实现这个接口或抽象类，然后在代理中注入实力工作的子类，通过代理来调用实际干活的类，可以在代理层做类似切面操作。
    jdk代理和cglib代理
# 行为型模式
 ## 1. 策略模式(strategy-pattern)
    所有的具体策略类都实现一个接口或抽象类，使用context上下文类来在外部注入具体策略实现，然后上下文类调用注入的策略类来干活。
    对客户端提供的只有context类。
 ## 2. 责任链模式(chain-pattern)
    所有的实现都放在一个集合中，然后遍历每一个实现，下发责任，如果当前类不负责此类，那么继续向下走。
 ## 3. 迭代器模式(iterator-pattern)
    iterator接口
 ## 4. 命令模式(command-pattern)
    将每一种可能封装为一个命令，客户端只与调用者交互，调用者来执行命令，解藕，高内聚
 ## 5. 解释器模式(interpreter-pattern)
 
 ## 6. 模板模式(template-pattern)
    如果一个接口的有多个子类，这些子类之间拥有共性，就将这些共性行为封装为模版方法，这样子类实现中只需要关注子类的个性，而不需要考虑共性问题，
    可以通过钩子函数来控制模版方法。如果某个子类要改变这些共性就重写模版方法。
 ## 7. 观察者模式(observer-pattern)
    观察者模式是一种一对多的对象解藕设计，是对象行为性模式。模式结构：
    抽象目标类：提供用于保存观察者对象的聚集类和增加删除观察者对象的方法。以及通知所有观察者的抽象方法。
    具体目标类：实现抽象目标中的通知方法，当具体主题内部状态发生改变时，通知所有注册过的观察者对象。
    抽象观察者：抽象类或接口，包含一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。
    具体观察者：实现抽象观察者中定义的抽象方法。
    被观察者和观察者是一对多的关系，也就是说当被观察者状态发生改变，那么会通知所有的观察者去做处理。
    
 ## 8. 中介者模式(mediator-pattern)
    多个类之间互相依赖，通过中介者模式来解藕
    抽象中介者：
    具体中介者：
    抽象同事：
    具体同事：
 ## 9. 访问者模式(visitor-pattern)
    在访问者接口中定义哪儿写对象可以被访问，访问元素中添加接受访问者的方法。
    抽象访问者：
    具体访问者：
    抽象元素：
    具体元素：
    业务规则要求遍历访问多个不同对象，要考虑访问者模式
 ## 10. 状态模式 (state-pattern)   
    状态变更引起行为变更，从外部看就好像这个对象对应的类发生了变更一样。
    行为受状态约束的情况可以使用状态模式。而且状态模式使用时对象的状态最好不要超过五个。状态模式符合迪米特法则。缺点子类膨胀。`
 ## 11. 备忘录模式
    